# Programming-in-PhaseField-Method---FEM-Code
对***Programming in PhaseField Method***这本书中的有限元法代码进行一个总结

## 代码整体架构
这是一个完整的二维线性弹性有限元求解器，包含从输入到输出的完整流程

## 1.主程序入口：fem_elast_v1.m
主要流程：  
读取输入文件（mesh_1.inp）   
读取有限元数据（节点、单元、材料属性等）   
组装全局刚度矩阵  
组装载荷向量并施加边界条件  
求解线性方程组得到位移  
后处理计算应力  
输出结果  

## 2.输入处理模块：input_fem_elast.m
读取内容：  
控制数据（节点数、单元数、边界条件数等）  
单元节点连接关系和材料编号  
节点坐标  
边界约束信息  
材料属性（弹性模量、泊松比等）  

## 3.核心计算模块
### 3.1 刚度矩阵组装：stiffness.m
原理：  
对每个单元，使用高斯积分计算单元刚度矩阵  
通过形函数、雅可比矩阵、B矩阵和本构矩阵组装单元刚度  
将单元刚度组装到全局刚度矩阵  

### 3.2 载荷处理：loads.m
支持：  
点载荷：直接施加在节点上  
分布载荷：通过边界积分将表面载荷转换为等效节点载荷  

### 3.3 边界条件处理：boundary_cond.m
使用罚函数法或直接修改法施加边界条件

## 4. 辅助计算函数
### 4.1 高斯积分：gauss.m
提供不同阶次的高斯积分点和权重：  
三角形单元：支持1点、3点、7点积分  
四边形单元：支持2点、3点等积分方案

### 4.2 形函数：sfr2.m
计算等参单元的形状函数及其导数，支持：  
3节点三角形单元（线性）  
4节点四边形单元（双线性）  
8节点四边形单元（二次）  

### 4.3 雅可比矩阵：jacob2.m
计算等参变换的雅可比矩阵：  
用于从自然坐标系转换到全局坐标系  
检查雅可比行列式，避免负面积或退化单元  

### 4.4 本构矩阵：modps.m
根据问题类型（平面应力或平面应变）计算弹性本构矩阵：    

## 5.后处理模块
### 5.1 应力计算：stress.m  
根据已求得的位移计算应力  
流程：  
从位移计算应变：ε = B·u  
从应变计算应力：σ = D·ε  

### 5.2 结果输出：output.m 和 write_vtk_fem.m
output.m：将结果写入文本文件（位移、应力等）  
write_vtk_fem.m：生成VTK格式文件，用于可视化（如ParaView）

## 代码特点总结
支持多种单元类型：3节点三角形、4节点和8节点四边形  
支持平面应力和平面应变两种问题类型  
使用等参单元和高斯数值积分  
支持多种载荷类型（点载荷、分布载荷）  
支持边界条件约束  
完整的后处理（应力计算、结果输出、可视化）  
这是一个教学型有限元代码，结构清晰，适合学习和理解有限元法的基本流程。代码涵盖了FEM的核心步骤，是理解相场建模中力学部分的基础

## ===========================分割线=============================
## 输入文件mesh_1介绍
下面按块来介绍 mesh_1.inp 的含义，它是这个有限元程序的完整输入文件，与 input_fem_elast.m、loads.m 一一对应  
### 1. 控制参数行（第 1 行）
```
40 9 14 2 8 2 2 3 3 1 2
```
对应 input_fem_elast.m 里依次读取的 11 个整数：
* npoin = 40：总节点数
* nelem = 9：总单元数
* nvfix = 14：受约束（施加位移边界条件）的节点数
* ntype = 2：问题类型---1：平面应力;2：平面应变
* nnode = 8：每个单元的节点数（8 节点二次四边形单元）
* ndofn = 2：每个节点的自由度数（2D：Ux, Uy）
* ndime = 2：问题空间维数（二维）
* ngaus = 3：高斯积分点数（每方向 3 点）
* nstre = 3：应力/应变分量数（σxx, σyy, σxy）
* nmats = 1：材料种类数（这里只有一种材料）
* nprop = 2：每种材料的属性个数（这里是 E、ν 两个）

### 2. 单元连接关系 + 材料编号（第 2–10 行）
以第2行为例
``` 1 1 2 3 9 14 13 12 8 1```
在 input_fem_elast.m 中按如下方式读：
* 第一个数：单元号 jelem（这里是 1）
* 后面 nnode + 1 = 9 个整数读入 dummy(1..9)  
  dummy(1..8)：该单元的 8 个节点号 → lnods(1,1..8)  
  dummy(9)：材料号 → matno(1)  

* 因此：  
  第 2 行：单元 1，节点序号为 [1 2 3 9 14 13 12 8]，材料号 1  
  第 3 行：单元 2，节点 [3 4 5 10 16 15 14 9]，材料号 1  
…  
  第 10 行：单元 9，节点 [27 28 29 33 40 39 38 32]，材料号 1  

这 9 行定义了全部 9 个 8 节点四边形单元的拓扑连接关系。

### 3. 节点坐标（第 11–50 行）
格式：
节点号     
x坐标   
y坐标  
例如：
```
11: 1  5.000  0.000
12: 2  6.667  0.000
...
50: 40 0.000 20.000
```
在 input_fem_elast.m 中：
* 读节点号 jpoint（这里就是 1,2,3,...,40）
* 读两个浮点数 dummy(1)=x, dummy(2)=y
* 存入 coord(ipoin,1:2)，即 coord(jpoint,:) = [x, y]

这一段给出40 个节点在二维平面中的几何位置，描述了整体结构的外形和网格划分。

### 4. 位移边界条件（第 51–64 行，共 nvfix = 14 行）
格式：  
节点号 iffix_x iffix_y fixed_x fixed_y  
例如前几行：
```
51: 1  0 1  0.0 0.0
52: 2  0 1  0.0 0.0...
57: 7  0 1  0.0 0.0
58: 34 1 0  0.0 0.0...
64: 40 1 0  0.0 0.0
```
在 input_fem_elast.m：
nofix(ivfix)：约束节点号
* dummy1 = fscanf(..., '%d %d') → [iffix_x, iffix_y]
* dummy2 = fscanf(..., '%lf %lf') → [fixed_x, fixed_y]
iffix(ivfix,idofn)：是否约束该自由度（1=约束，0=不约束）
fixed(ivfix,idofn)：该自由度的位移值（通常为 0）

含义：第 51–57 行：节点 1–7  
* 0 1 → 只约束 y 方向位移（Uy=0），x 方向自由
第 58–64 行：节点 34–40
* 1 0 → 只约束 x 方向位移（Ux=0），y 方向自由
这定义了结构左右或上下边界的固支/滑移等边界条件

### 5. 材料参数（第 65 行）
```
65: 1 10000.0 0.3
```
在 input_fem_elast.m 中：读入材料号 jmats = 1  
再读入两个实数：[10000.0, 0.3]  
存入 props(1,1) = 10000.0, props(1,2) = 0.3  
结合 modps.m：  
* E = 10000.0：弹性模量
* ν = 0.3：泊松比

因为 ntype = 2（平面应变），在 modps.m 中会按平面应变公式组成本构矩阵 D。

### 6. 载荷控制参数（第 66 行）
```
66: 0 3
```
在 loads.m 中：
* dummy = fscanf(in, '%d %d', [2, 1]);iplod = dummy(1);nedge = dummy(2);

含义：
* iplod = 0：没有点载荷
* nedge = 3：有 3 条边施加分布载荷（压力/表面力）

### 7. 边界分布载荷定义（第 67–78 行）
结构是按每条边块状给出，3 条边，所以有 3 组完全相同的格式
每条边的格式（参考 loads.m）：
* 一行：单元号neass = fscanf(in,'%d',[1,1]);   % 这一条边所属的单元号
* 一行：nodeg 个整数（对 8 节点单元，nodeg=3），是边上的节点号dummy = fscanf(in,'%d %d %d',[nodeg,1]);
  noprs(iodeg) = dummy(iodeg);     % 这条边的节点编号

接下来 nodeg 行：每行两个数，对应该边上每个节点的载荷分量（Fx,Fy）
* dummy = fscanf(in,'%lf %lf',[2,1]);   press(iodeg,idofn) = dummy(idofn);  % 该节点处的分布力

对应到文件：
第 1 条边（第 67–70 行）
```
67: 1 12 8 168: 10.0 0.069: 10.0 0.070: 10.0 0.0
```
neass = 1：这条受载边属于单元 1  
noprs = [12, 8, 1]：边上的 3 个节点是 12、8、1  

三行载荷：
* 节点 12：Fx=10, Fy=0
* 节点 8：Fx=10, Fy=0
* 节点 1：Fx=10, Fy=0

说明：单元 1 的某一条边（节点 12-8-1 这条边）在 x 方向受均布拉力 10（单位见你物理量设定）  

第 2 条边（第 71–74 行）
```
71: 4 23 19 1272: 10.0 0.073: 10.0 0.074: 10.0 0.0
```
neass = 4：属于单元 4  
noprs = [23, 19, 12]  
三个节点 23、19、12 在 x 方向各有 10 的表面力  

第 3 条边（第 75–78 行）
```
75: 7 34 30 2376: 10.0 0.077: 10.0 0.078: 10.0 0.0
```
neass = 7：属于单元 7  
noprs = [34, 30, 23]  
三个节点 34、30、23 在 x 方向各有 10 的表面力  
这 3 组数据定义了结构右侧某条边上的沿 x 方向的分布拉力，loads.m 会将它通过高斯积分转换成等效的节点力，组装进全局载荷向量 gforce  

### 小结
几何/网格信息：
* 第 1 行：整体模型与数值设置（节点数、单元数、单元类型、积分点数、材料数等）
* 第 2–10 行：每个单元的 8 个节点号 + 材料号
* 第 11–50 行：40 个节点的坐标
* 边界与材料信息：
* 第 51–64 行：14 个受约束节点的位移边界条件（约束哪个自由度、约束值）
* 第 65 行：材料号 1 的参数：E=10000, ν=0.3

载荷信息：
* 第 66 行：没有点载荷，有 3 条边有分布载荷
* 第 67–78 行：3 条边分别属于单元 1、4、7，在这些边上 3 个节点给出同样的水平分布载荷（10,0）
